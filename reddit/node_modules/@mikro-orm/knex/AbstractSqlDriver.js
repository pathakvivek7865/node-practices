"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSqlDriver = void 0;
const core_1 = require("@mikro-orm/core");
const QueryBuilder_1 = require("./query/QueryBuilder");
const SqlEntityManager_1 = require("./SqlEntityManager");
class AbstractSqlDriver extends core_1.DatabaseDriver {
    constructor(config, platform, connection, connector) {
        super(config, connector);
        this.replicas = [];
        this.connection = new connection(this.config);
        this.replicas = this.createReplicas(conf => new connection(this.config, conf, 'read'));
        this.platform = platform;
    }
    getPlatform() {
        return this.platform;
    }
    createEntityManager(useContext) {
        return new SqlEntityManager_1.SqlEntityManager(this.config, this, this.metadata, useContext);
    }
    async find(entityName, where, options = {}, ctx) {
        options = Object.assign({ populate: [], orderBy: {} }, options);
        const meta = this.metadata.find(entityName);
        const populate = this.autoJoinOneToOneOwner(meta, options.populate);
        const joinedProps = this.joinedProps(meta, populate);
        const qb = this.createQueryBuilder(entityName, ctx, !!ctx).unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES);
        const fields = this.buildFields(meta, populate, joinedProps, qb, options.fields);
        if (core_1.Utils.isPrimaryKey(where, meta.compositePK)) {
            where = { [core_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: where };
        }
        qb.select(fields)
            .populate(populate)
            .where(where)
            .orderBy(options.orderBy)
            .groupBy(options.groupBy)
            .having(options.having)
            .withSchema(options.schema);
        if (options.limit !== undefined) {
            qb.limit(options.limit, options.offset);
        }
        core_1.Utils.asArray(options.flags).forEach(flag => qb.setFlag(flag));
        const result = await this.rethrow(qb.execute('all'));
        if (joinedProps.length > 0) {
            return this.mergeJoinedResult(result, meta);
        }
        return result;
    }
    async findOne(entityName, where, options, ctx) {
        const opts = Object.assign({ populate: [] }, (options || {}));
        const meta = this.metadata.find(entityName);
        const populate = this.autoJoinOneToOneOwner(meta, opts.populate);
        const joinedProps = this.joinedProps(meta, populate);
        if (joinedProps.length === 0) {
            opts.limit = 1;
        }
        const res = await this.find(entityName, where, opts, ctx);
        return res[0] || null;
    }
    mapResult(result, meta, populate = [], qb, map = {}) {
        const ret = super.mapResult(result, meta);
        if (!ret) {
            return null;
        }
        if (qb) {
            this.mapJoinedProps(ret, meta, populate, qb, ret, map);
        }
        return ret;
    }
    mapJoinedProps(result, meta, populate, qb, root, map, parentJoinPath) {
        const joinedProps = this.joinedProps(meta, populate);
        joinedProps.forEach(p => {
            const relation = meta.properties[p.field];
            const meta2 = this.metadata.find(relation.type);
            const path = parentJoinPath ? `${parentJoinPath}.${relation.name}` : `${meta.name}.${relation.name}`;
            const relationAlias = qb.getAliasForJoinPath(path);
            const relationPojo = {};
            // If the primary key value for the relation is null, we know we haven't joined to anything
            // and therefore we don't return any record (since all values would be null)
            const hasPK = meta2.primaryKeys.every(pk => meta2.properties[pk].fieldNames.every(name => {
                return core_1.Utils.isDefined(root[`${relationAlias}_${name}`], true);
            }));
            if (!hasPK) {
                return;
            }
            Object.values(meta2.properties)
                .filter(prop => this.shouldHaveColumn(prop, populate))
                .forEach(prop => {
                if (prop.fieldNames.length > 1) { // composite keys
                    relationPojo[prop.name] = prop.fieldNames.map(name => root[`${relationAlias}_${name}`]);
                    prop.fieldNames.map(name => delete root[`${relationAlias}_${name}`]);
                }
                else {
                    const alias = `${relationAlias}_${prop.fieldNames[0]}`;
                    relationPojo[prop.name] = root[alias];
                    delete root[alias];
                }
            });
            const key = `${meta.name}-${(core_1.Utils.getCompositeKeyHash(result, meta))}`;
            if (map[key]) {
                result[relation.name] = map[key][relation.name];
            }
            else {
                map[key] = result;
                result[relation.name] = result[relation.name] || [];
            }
            if ([core_1.ReferenceType.MANY_TO_MANY, core_1.ReferenceType.ONE_TO_MANY].includes(relation.reference)) {
                this.appendToCollection(meta2, result[relation.name], relationPojo);
            }
            else {
                result[relation.name] = relationPojo;
            }
            const populateChildren = p.children || [];
            this.mapJoinedProps(relationPojo, meta2, populateChildren, qb, root, map, path);
        });
    }
    appendToCollection(meta, collection, relationPojo) {
        if (collection.length === 0) {
            return void collection.push(relationPojo);
        }
        const last = collection[collection.length - 1];
        const pk1 = core_1.Utils.getCompositeKeyHash(last, meta);
        const pk2 = core_1.Utils.getCompositeKeyHash(relationPojo, meta);
        if (pk1 !== pk2) {
            collection.push(relationPojo);
        }
    }
    async count(entityName, where, ctx) {
        const pks = this.metadata.find(entityName).primaryKeys;
        const qb = this.createQueryBuilder(entityName, ctx, !!ctx)
            .unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES)
            .count(pks, true)
            .where(where);
        const res = await this.rethrow(qb.execute('get', false));
        return +res.count;
    }
    async nativeInsert(entityName, data, ctx) {
        const meta = this.metadata.find(entityName);
        const collections = this.extractManyToMany(entityName, data);
        const pks = this.getPrimaryKeyFields(entityName);
        const qb = this.createQueryBuilder(entityName, ctx, true);
        const res = await this.rethrow(qb.insert(data).execute('run', false));
        res.row = res.row || {};
        let pk;
        if (pks.length > 1) { // owner has composite pk
            pk = core_1.Utils.getPrimaryKeyCond(data, pks);
        }
        else {
            res.insertId = data[pks[0]] || res.insertId || res.row[pks[0]];
            pk = [res.insertId];
        }
        await this.processManyToMany(meta, pk, collections, false, ctx);
        return res;
    }
    async nativeInsertMany(entityName, data, ctx) {
        const meta = this.metadata.find(entityName);
        const collections = data.map(d => this.extractManyToMany(entityName, d));
        const pks = this.getPrimaryKeyFields(entityName);
        const qb = this.createQueryBuilder(entityName, ctx, true);
        const res = await this.rethrow(qb.insert(data).execute('run', false));
        let pk;
        /* istanbul ignore next  */
        if (pks.length > 1) { // owner has composite pk
            pk = data.map(d => core_1.Utils.getPrimaryKeyCond(d, pks));
        }
        else {
            pk = data.map((d, i) => { var _a, _b; return (_a = d[pks[0]]) !== null && _a !== void 0 ? _a : (_b = res.rows[i]) === null || _b === void 0 ? void 0 : _b[pks[0]]; }).map(d => [d]);
            res.insertId = res.insertId || res.row[pks[0]];
        }
        for (let i = 0; i < collections.length; i++) {
            await this.processManyToMany(meta, pk[i], collections[i], false, ctx);
        }
        return res;
    }
    async nativeUpdate(entityName, where, data, ctx) {
        const meta = this.metadata.find(entityName);
        const pks = this.getPrimaryKeyFields(entityName);
        const collections = this.extractManyToMany(entityName, data);
        let res = { affectedRows: 0, insertId: 0, row: {} };
        if (core_1.Utils.isPrimaryKey(where) && pks.length === 1) {
            where = { [pks[0]]: where };
        }
        if (Object.keys(data).length > 0) {
            const qb = this.createQueryBuilder(entityName, ctx, true)
                .unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES)
                .update(data)
                .where(where);
            res = await this.rethrow(qb.execute('run', false));
        }
        const pk = pks.map(pk => core_1.Utils.extractPK(data[pk] || where, meta));
        await this.processManyToMany(meta, pk, collections, true, ctx);
        return res;
    }
    async nativeDelete(entityName, where, ctx) {
        const pks = this.getPrimaryKeyFields(entityName);
        if (core_1.Utils.isPrimaryKey(where) && pks.length === 1) {
            where = { [pks[0]]: where };
        }
        const qb = this.createQueryBuilder(entityName, ctx, true).unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES).delete(where);
        return this.rethrow(qb.execute('run', false));
    }
    async syncCollection(coll, ctx) {
        const wrapped = coll.owner.__helper;
        const meta = wrapped.__meta;
        const pks = wrapped.__primaryKeys;
        const snap = coll.getSnapshot();
        const includes = (arr, item) => !!arr.find(i => core_1.Utils.equals(i, item));
        const snapshot = snap ? snap.map(item => item.__helper.__primaryKeys) : [];
        const current = coll.getItems(false).map(item => item.__helper.__primaryKeys);
        const deleteDiff = snap ? snapshot.filter(item => !includes(current, item)) : true;
        const insertDiff = current.filter(item => !includes(snapshot, item));
        const target = snapshot.filter(item => includes(current, item)).concat(...insertDiff);
        const equals = core_1.Utils.equals(current, target);
        // wrong order if we just delete and insert to the end (only owning sides can have fixed order)
        if (coll.property.owner && coll.property.fixedOrder && !equals && Array.isArray(deleteDiff)) {
            deleteDiff.length = insertDiff.length = 0;
            deleteDiff.push(...snapshot);
            insertDiff.push(...current);
        }
        if (coll.property.reference === core_1.ReferenceType.ONE_TO_MANY) {
            const cols = coll.property.referencedColumnNames;
            const qb = this.createQueryBuilder(coll.property.type, ctx, true)
                .unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES)
                .update({ [coll.property.mappedBy]: pks })
                .getKnexQuery()
                .whereIn(cols, insertDiff);
            return this.rethrow(qb);
        }
        return this.rethrow(this.updateCollectionDiff(meta, coll.property, pks, deleteDiff, insertDiff, ctx));
    }
    async loadFromPivotTable(prop, owners, where = {}, orderBy, ctx) {
        const pivotProp2 = this.getPivotInverseProperty(prop);
        const ownerMeta = this.metadata.find(pivotProp2.type);
        const targetMeta = this.metadata.find(prop.type);
        const cond = { [`${prop.pivotTable}.${pivotProp2.name}`]: { $in: ownerMeta.compositePK ? owners : owners.map(o => o[0]) } };
        if (!core_1.Utils.isEmpty(where) && Object.keys(where).every(k => core_1.Utils.isOperator(k, false))) {
            where = cond;
        }
        else {
            where = Object.assign(Object.assign({}, where), cond);
        }
        orderBy = this.getPivotOrderBy(prop, orderBy);
        const qb = this.createQueryBuilder(prop.type, ctx, !!ctx).unsetFlag(core_1.QueryFlag.CONVERT_CUSTOM_TYPES);
        const populate = this.autoJoinOneToOneOwner(targetMeta, [{
                field: prop.pivotTable,
            }]);
        qb.select('*').populate(populate).where(where).orderBy(orderBy);
        const items = owners.length ? await this.rethrow(qb.execute('all')) : [];
        const map = {};
        owners.forEach(owner => map['' + core_1.Utils.getPrimaryKeyHash(owner)] = []);
        items.forEach((item) => {
            const key = core_1.Utils.getPrimaryKeyHash(prop.joinColumns.map(col => item[col]));
            map[key].push(item);
            prop.joinColumns.forEach(col => delete item[col]);
            prop.inverseJoinColumns.forEach(col => delete item[col]);
        });
        return map;
    }
    async execute(queryOrKnex, params = [], method = 'all', ctx) {
        return this.rethrow(this.connection.execute(queryOrKnex, params, method, ctx));
    }
    /**
     * 1:1 owner side needs to be marked for population so QB auto-joins the owner id
     */
    autoJoinOneToOneOwner(meta, populate) {
        if (!this.config.get('autoJoinOneToOneOwner')) {
            return populate;
        }
        const relationsToPopulate = populate.map(({ field }) => field);
        const toPopulate = Object.values(meta.properties)
            .filter(prop => prop.reference === core_1.ReferenceType.ONE_TO_ONE && !prop.owner && !relationsToPopulate.includes(prop.name))
            .map(prop => ({ field: prop.name, strategy: prop.strategy }));
        return [...populate, ...toPopulate];
    }
    joinedProps(meta, populate) {
        return populate.filter(p => {
            const prop = meta.properties[p.field] || {};
            return (p.strategy || prop.strategy) === core_1.LoadStrategy.JOINED && prop.reference !== core_1.ReferenceType.SCALAR;
        });
    }
    mergeJoinedResult(rawResults, meta) {
        // group by the root entity primary key first
        const res = rawResults.reduce((result, item) => {
            const pk = core_1.Utils.getCompositeKeyHash(item, meta);
            result[pk] = result[pk] || [];
            result[pk].push(item);
            return result;
        }, {});
        return Object.values(res).map((rows) => rows[0]);
    }
    getFieldsForJoinedLoad(qb, meta, populate = [], parentTableAlias, parentJoinPath) {
        const fields = [];
        const joinedProps = this.joinedProps(meta, populate);
        // alias all fields in the primary table
        Object.values(meta.properties)
            .filter(prop => this.shouldHaveColumn(prop, populate))
            .forEach(prop => fields.push(...this.mapPropToFieldNames(qb, prop, parentTableAlias)));
        joinedProps.forEach(relation => {
            const prop = meta.properties[relation.field];
            const meta2 = this.metadata.find(prop.type);
            const tableAlias = qb.getNextAlias(prop.name);
            const field = parentTableAlias ? `${parentTableAlias}.${prop.name}` : prop.name;
            const path = parentJoinPath ? `${parentJoinPath}.${prop.name}` : `${meta.name}.${prop.name}`;
            qb.join(field, tableAlias, {}, 'leftJoin', path);
            fields.push(...this.getFieldsForJoinedLoad(qb, meta2, relation.children, tableAlias, path));
        });
        return fields;
    }
    mapPropToFieldNames(qb, prop, tableAlias) {
        if (prop.formula) {
            const alias = qb.ref(tableAlias !== null && tableAlias !== void 0 ? tableAlias : qb.alias).toString();
            const aliased = qb.ref(tableAlias ? `${tableAlias}_${prop.fieldNames[0]}` : prop.fieldNames[0]).toString();
            return [`${prop.formula(alias)} as ${aliased}`];
        }
        if (tableAlias) {
            return prop.fieldNames.map(fieldName => qb.ref(fieldName).withSchema(tableAlias).as(`${tableAlias}_${fieldName}`));
        }
        return prop.fieldNames;
    }
    createQueryBuilder(entityName, ctx, write) {
        return new QueryBuilder_1.QueryBuilder(entityName, this.metadata, this, ctx, undefined, write ? 'write' : 'read');
    }
    extractManyToMany(entityName, data) {
        if (!this.metadata.has(entityName)) {
            return {};
        }
        const props = this.metadata.find(entityName).properties;
        const ret = {};
        for (const k of Object.keys(data)) {
            const prop = props[k];
            if (prop && prop.reference === core_1.ReferenceType.MANY_TO_MANY) {
                ret[k] = data[k].map((item) => core_1.Utils.asArray(item));
                delete data[k];
            }
        }
        return ret;
    }
    async processManyToMany(meta, pks, collections, clear, ctx) {
        if (!meta) {
            return;
        }
        const props = meta.properties;
        for (const k of Object.keys(collections)) {
            await this.rethrow(this.updateCollectionDiff(meta, props[k], pks, clear, collections[k], ctx));
        }
    }
    async updateCollectionDiff(meta, prop, pks, deleteDiff, insertDiff, ctx) {
        const meta2 = this.metadata.find(prop.type);
        if (!deleteDiff) {
            deleteDiff = [];
        }
        if (deleteDiff === true || deleteDiff.length > 0) {
            const qb1 = this.createQueryBuilder(prop.pivotTable, ctx, true);
            const knex = qb1.getKnex();
            if (Array.isArray(deleteDiff)) {
                knex.whereIn(prop.inverseJoinColumns, deleteDiff);
            }
            meta2.primaryKeys.forEach((pk, idx) => knex.andWhere(prop.joinColumns[idx], pks[idx]));
            await this.execute(knex.delete());
        }
        const items = insertDiff.map(item => {
            const cond = {};
            prop.joinColumns.forEach((joinColumn, idx) => cond[joinColumn] = pks[idx]);
            prop.inverseJoinColumns.forEach((inverseJoinColumn, idx) => cond[inverseJoinColumn] = item[idx]);
            return cond;
        });
        if (this.platform.allowsMultiInsert()) {
            const qb2 = this.createQueryBuilder(prop.pivotTable, ctx, true);
            await this.execute(qb2.getKnex().insert(items));
        }
        else {
            await core_1.Utils.runSerial(items, item => this.createQueryBuilder(prop.pivotTable, ctx, true).insert(item).execute('run', false));
        }
    }
    async lockPessimistic(entity, mode, ctx) {
        const qb = this.createQueryBuilder(entity.constructor.name, ctx);
        const meta = entity.__helper.__meta;
        const cond = core_1.Utils.getPrimaryKeyCond(entity, meta.primaryKeys);
        qb.select('1').where(cond).setLockMode(mode);
        await this.rethrow(qb.execute());
    }
    buildFields(meta, populate, joinedProps, qb, fields) {
        const lazyProps = Object.values(meta.properties).filter(prop => prop.lazy && !populate.some(p => p.field === prop.name || p.all));
        const hasExplicitFields = !!fields;
        if (fields) {
            fields.unshift(...meta.primaryKeys.filter(pk => !fields.includes(pk)));
        }
        else if (joinedProps.length > 0) {
            fields = this.getFieldsForJoinedLoad(qb, meta, populate);
        }
        else if (lazyProps.length > 0) {
            const props = Object.values(meta.properties).filter(prop => this.shouldHaveColumn(prop, populate, false));
            fields = core_1.Utils.flatten(props.filter(p => !lazyProps.includes(p)).map(p => p.fieldNames));
        }
        if (fields && !hasExplicitFields) {
            Object.values(meta.properties)
                .filter(prop => prop.formula)
                .forEach(prop => {
                const alias = qb.ref(qb.alias).toString();
                const aliased = qb.ref(prop.fieldNames[0]).toString();
                fields.push(`${prop.formula(alias)} as ${aliased}`);
            });
        }
        return fields || ['*'];
    }
}
exports.AbstractSqlDriver = AbstractSqlDriver;
