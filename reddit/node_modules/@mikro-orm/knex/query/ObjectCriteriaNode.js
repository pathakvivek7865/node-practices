"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectCriteriaNode = void 0;
const core_1 = require("@mikro-orm/core");
const CriteriaNode_1 = require("./CriteriaNode");
const enums_1 = require("./enums");
class ObjectCriteriaNode extends CriteriaNode_1.CriteriaNode {
    process(qb, alias) {
        const nestedAlias = qb.getAliasForJoinPath(this.getPath());
        const ownerAlias = alias || qb.alias;
        if (nestedAlias) {
            alias = nestedAlias;
        }
        if (this.shouldAutoJoin(nestedAlias)) {
            alias = this.autoJoin(qb, ownerAlias);
        }
        return Object.keys(this.payload).reduce((o, field) => {
            var _a;
            const childNode = this.payload[field];
            const payload = childNode.process(qb, this.prop ? alias : ownerAlias);
            const operator = core_1.Utils.isOperator(field);
            const customExpression = ObjectCriteriaNode.isCustomExpression(field);
            const virtual = ((_a = childNode.prop) === null || _a === void 0 ? void 0 : _a.persist) === false;
            if (childNode.shouldInline(payload)) {
                const operators = Object.keys(payload).filter(k => core_1.Utils.isOperator(k, false));
                operators.forEach(op => {
                    const tmp = payload[op];
                    delete payload[op];
                    payload[`${alias}.${field}`] = Object.assign({ [op]: tmp }, (payload[`${alias}.${field}`] || {}));
                });
                Object.assign(o, payload);
            }
            else if (childNode.shouldRename(payload)) {
                o[childNode.renameFieldToPK(qb)] = payload;
            }
            else if (virtual || operator || customExpression || field.includes('.') || ![enums_1.QueryType.SELECT, enums_1.QueryType.COUNT].includes(qb.type)) {
                o[field] = payload;
            }
            else {
                o[`${alias}.${field}`] = payload;
            }
            return o;
        }, {});
    }
    willAutoJoin(qb, alias) {
        const nestedAlias = qb.getAliasForJoinPath(this.getPath());
        const ownerAlias = alias || qb.alias;
        if (nestedAlias) {
            alias = nestedAlias;
        }
        if (this.shouldAutoJoin(nestedAlias)) {
            return true;
        }
        return Object.keys(this.payload).some(field => {
            const childNode = this.payload[field];
            return childNode.willAutoJoin(qb, this.prop ? alias : ownerAlias);
        });
    }
    shouldInline(payload) {
        const customExpression = ObjectCriteriaNode.isCustomExpression(this.key);
        const scalar = core_1.Utils.isPrimaryKey(payload) || payload instanceof RegExp || payload instanceof Date || customExpression;
        const operator = core_1.Utils.isObject(payload) && Object.keys(payload).every(k => core_1.Utils.isOperator(k, false));
        return !!this.prop && this.prop.reference !== core_1.ReferenceType.SCALAR && !scalar && !operator;
    }
    shouldAutoJoin(nestedAlias) {
        if (!this.prop || !this.parent) {
            return false;
        }
        const embeddable = this.prop.reference === core_1.ReferenceType.EMBEDDED;
        const knownKey = [core_1.ReferenceType.SCALAR, core_1.ReferenceType.MANY_TO_ONE, core_1.ReferenceType.EMBEDDED].includes(this.prop.reference) || (this.prop.reference === core_1.ReferenceType.ONE_TO_ONE && this.prop.owner);
        const operatorKeys = knownKey && Object.keys(this.payload).every(key => core_1.Utils.isOperator(key, false));
        return !nestedAlias && !operatorKeys && !embeddable;
    }
    autoJoin(qb, alias) {
        const nestedAlias = qb.getNextAlias();
        const customExpression = ObjectCriteriaNode.isCustomExpression(this.key);
        const scalar = core_1.Utils.isPrimaryKey(this.payload) || this.payload instanceof RegExp || this.payload instanceof Date || customExpression;
        const operator = core_1.Utils.isPlainObject(this.payload) && Object.keys(this.payload).every(k => core_1.Utils.isOperator(k, false));
        const field = `${alias}.${this.prop.name}`;
        if (this.prop.reference === core_1.ReferenceType.MANY_TO_MANY && (scalar || operator)) {
            qb.join(field, nestedAlias, undefined, 'pivotJoin', this.getPath());
        }
        else {
            const prev = qb._fields.slice();
            qb.join(field, nestedAlias, undefined, 'leftJoin', this.getPath());
            qb._fields = prev;
        }
        return nestedAlias;
    }
}
exports.ObjectCriteriaNode = ObjectCriteriaNode;
