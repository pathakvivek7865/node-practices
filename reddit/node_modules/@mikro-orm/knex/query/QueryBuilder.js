"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryBuilder = void 0;
const core_1 = require("@mikro-orm/core");
const enums_1 = require("./enums");
const QueryBuilderHelper_1 = require("./QueryBuilderHelper");
const CriteriaNodeFactory_1 = require("./CriteriaNodeFactory");
/**
 * SQL query builder
 */
class QueryBuilder {
    constructor(entityName, metadata, driver, context, alias = `e0`, connectionType, em) {
        this.entityName = entityName;
        this.metadata = metadata;
        this.driver = driver;
        this.context = context;
        this.alias = alias;
        this.connectionType = connectionType;
        this.em = em;
        this._populate = [];
        this._populateMap = {};
        this.aliasCounter = 1;
        this.flags = new Set([core_1.QueryFlag.CONVERT_CUSTOM_TYPES]);
        this.finalized = false;
        this._joins = {};
        this._aliasMap = {};
        this._cond = {};
        this._orderBy = {};
        this._groupBy = [];
        this._having = {};
        this.subQueries = {};
        this.platform = this.driver.getPlatform();
        this.knex = this.driver.getConnection(this.connectionType).getKnex();
        this.helper = new QueryBuilderHelper_1.QueryBuilderHelper(this.entityName, this.alias, this._aliasMap, this.subQueries, this.metadata, this.knex, this.platform);
        this._aliasMap[this.alias] = this.entityName;
    }
    select(fields, distinct = false) {
        this._fields = core_1.Utils.asArray(fields);
        if (distinct) {
            this.flags.add(core_1.QueryFlag.DISTINCT);
        }
        return this.init(enums_1.QueryType.SELECT);
    }
    addSelect(fields) {
        return this.select([...core_1.Utils.asArray(this._fields), ...core_1.Utils.asArray(fields)]);
    }
    insert(data) {
        return this.init(enums_1.QueryType.INSERT, data);
    }
    update(data) {
        return this.init(enums_1.QueryType.UPDATE, data);
    }
    delete(cond = {}) {
        return this.init(enums_1.QueryType.DELETE, undefined, cond);
    }
    truncate() {
        return this.init(enums_1.QueryType.TRUNCATE);
    }
    count(field, distinct = false) {
        this._fields = [...(field ? core_1.Utils.asArray(field) : this.metadata.find(this.entityName).primaryKeys)];
        if (distinct) {
            this.flags.add(core_1.QueryFlag.DISTINCT);
        }
        return this.init(enums_1.QueryType.COUNT);
    }
    join(field, alias, cond = {}, type = 'innerJoin', path) {
        this.joinReference(field, alias, cond, type, path);
        return this;
    }
    leftJoin(field, alias, cond = {}) {
        return this.join(field, alias, cond, 'leftJoin');
    }
    withSubQuery(subQuery, alias) {
        this.subQueries[alias] = subQuery.toString();
        return this;
    }
    where(cond, params, operator) {
        if (core_1.Utils.isString(cond)) {
            cond = { [`(${cond})`]: core_1.Utils.asArray(params) };
            operator = operator || '$and';
        }
        else {
            cond = core_1.QueryHelper.processWhere(cond, this.entityName, this.metadata, this.platform, this.flags.has(core_1.QueryFlag.CONVERT_CUSTOM_TYPES));
        }
        const op = operator || params;
        const topLevel = !op || Object.keys(this._cond).length === 0;
        const criteriaNode = CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.entityName, cond);
        if ([enums_1.QueryType.UPDATE, enums_1.QueryType.DELETE].includes(this.type) && criteriaNode.willAutoJoin(this)) {
            // use sub-query to support joining
            this.setFlag(this.type === enums_1.QueryType.UPDATE ? core_1.QueryFlag.UPDATE_SUB_QUERY : core_1.QueryFlag.DELETE_SUB_QUERY);
            this.select(this.metadata.find(this.entityName).primaryKeys, true);
        }
        if (topLevel) {
            this._cond = criteriaNode.process(this);
        }
        else if (Array.isArray(this._cond[op])) {
            this._cond[op].push(criteriaNode.process(this));
        }
        else {
            const cond1 = [this._cond, criteriaNode.process(this)];
            this._cond = { [op]: cond1 };
        }
        return this;
    }
    andWhere(cond, params) {
        return this.where(cond, params, '$and');
    }
    orWhere(cond, params) {
        return this.where(cond, params, '$or');
    }
    orderBy(orderBy) {
        core_1.QueryHelper.inlinePrimaryKeyObjects(orderBy, this.metadata.find(this.entityName), this.metadata);
        this._orderBy = CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.entityName, orderBy).process(this);
        return this;
    }
    groupBy(fields) {
        this._groupBy = core_1.Utils.asArray(fields);
        return this;
    }
    having(cond = {}, params) {
        if (core_1.Utils.isString(cond)) {
            cond = { [`(${cond})`]: core_1.Utils.asArray(params) };
        }
        this._having = CriteriaNodeFactory_1.CriteriaNodeFactory.createNode(this.metadata, this.entityName, cond).process(this);
        return this;
    }
    /**
     * @internal
     */
    populate(populate) {
        this._populate = populate;
        return this;
    }
    /**
     * @internal
     */
    ref(field) {
        return this.knex.ref(field);
    }
    raw(sql) {
        return this.knex.raw(sql);
    }
    limit(limit, offset = 0) {
        this._limit = limit;
        if (offset) {
            this.offset(offset);
        }
        return this;
    }
    offset(offset) {
        this._offset = offset;
        return this;
    }
    withSchema(schema) {
        this._schema = schema;
        return this;
    }
    setLockMode(mode) {
        if ([core_1.LockMode.NONE, core_1.LockMode.PESSIMISTIC_READ, core_1.LockMode.PESSIMISTIC_WRITE].includes(mode) && !this.context) {
            throw core_1.ValidationError.transactionRequired();
        }
        this.lockMode = mode;
        return this;
    }
    setFlag(flag) {
        this.flags.add(flag);
        return this;
    }
    unsetFlag(flag) {
        this.flags.delete(flag);
        return this;
    }
    getKnexQuery() {
        this.finalize();
        const qb = this.getQueryBase();
        core_1.Utils.runIfNotEmpty(() => this.helper.appendQueryCondition(this.type, this._cond, qb), this._cond);
        core_1.Utils.runIfNotEmpty(() => qb.groupBy(this.prepareFields(this._groupBy, 'groupBy')), this._groupBy);
        core_1.Utils.runIfNotEmpty(() => this.helper.appendQueryCondition(this.type, this._having, qb, undefined, 'having'), this._having);
        core_1.Utils.runIfNotEmpty(() => qb.orderByRaw(this.helper.getQueryOrder(this.type, this._orderBy, this._populateMap)), this._orderBy);
        core_1.Utils.runIfNotEmpty(() => qb.limit(this._limit), this._limit);
        core_1.Utils.runIfNotEmpty(() => qb.offset(this._offset), this._offset);
        if (this.type === enums_1.QueryType.TRUNCATE && this.platform.usesCascadeStatement()) {
            return this.knex.raw(qb.toSQL().toNative().sql + ' cascade');
        }
        this.helper.getLockSQL(qb, this.lockMode);
        this.helper.finalize(this.type, qb, this.metadata.find(this.entityName));
        return qb;
    }
    getQuery() {
        return this.getKnexQuery().toSQL().toNative().sql;
    }
    getParams() {
        return this.getKnexQuery().toSQL().toNative().bindings;
    }
    getAliasForJoinPath(path) {
        if (!path || path === this.entityName) {
            return this.alias;
        }
        const join = Object.values(this._joins).find(j => j.path === path);
        /* istanbul ignore next */
        return (join === null || join === void 0 ? void 0 : join.inverseAlias) || (join === null || join === void 0 ? void 0 : join.alias);
    }
    getNextAlias(prefix = 'e') {
        // Take only the first letter of the prefix to keep character counts down since some engines have character limits
        return `${prefix.charAt(0).toLowerCase()}${this.aliasCounter++}`;
    }
    async execute(method = 'all', mapResults = true) {
        const type = this.connectionType || (method === 'run' ? 'write' : 'read');
        const res = await this.driver.getConnection(type).execute(this.getKnexQuery(), [], method);
        const meta = this.metadata.find(this.entityName);
        if (!mapResults || !meta) {
            return res;
        }
        if (method === 'all' && Array.isArray(res)) {
            const map = {};
            return res.map(r => this.driver.mapResult(r, meta, this._populate, this, map));
        }
        return this.driver.mapResult(res, meta, this._populate, this);
    }
    async getResult() {
        return this.getResultList();
    }
    async getResultList() {
        const res = await this.execute('all', true);
        return res.map(r => this.em.map(this.entityName, r));
    }
    async getSingleResult() {
        const res = await this.getResult();
        return res[0] || null;
    }
    /**
     * Returns knex instance with sub-query aliased with given alias.
     * You can provide `EntityName.propName` as alias, then the field name will be used based on the metadata
     */
    as(alias) {
        var _a;
        const qb = this.getKnexQuery();
        if (alias.includes('.')) {
            const [a, f] = alias.split('.');
            const meta = this.metadata.find(a);
            /* istanbul ignore next */
            alias = ((_a = meta === null || meta === void 0 ? void 0 : meta.properties[f]) === null || _a === void 0 ? void 0 : _a.fieldNames[0]) || alias;
        }
        return qb.as(alias);
    }
    clone() {
        const qb = new QueryBuilder(this.entityName, this.metadata, this.driver, this.context, this.alias, this.connectionType, this.em);
        Object.assign(qb, this);
        // clone array/object properties
        const properties = ['flags', '_fields', '_populate', '_populateMap', '_joins', '_aliasMap', '_cond', '_data', '_orderBy', '_schema', 'subQueries'];
        properties.forEach(prop => qb[prop] = core_1.Utils.copy(this[prop]));
        qb.finalized = false;
        return qb;
    }
    getKnex() {
        const tableName = this.helper.getTableName(this.entityName) + (this.finalized && [enums_1.QueryType.SELECT, enums_1.QueryType.COUNT].includes(this.type) ? ` as ${this.alias}` : '');
        const qb = this.knex(tableName);
        if (this.context) {
            qb.transacting(this.context);
        }
        return qb;
    }
    joinReference(field, alias, cond, type, path) {
        const [fromAlias, fromField] = this.helper.splitField(field);
        const entityName = this._aliasMap[fromAlias];
        const prop = this.metadata.get(entityName).properties[fromField];
        this._aliasMap[alias] = prop.type;
        cond = core_1.QueryHelper.processWhere(cond, this.entityName, this.metadata, this.platform);
        const aliasedName = `${fromAlias}.${prop.name}`;
        if (prop.reference === core_1.ReferenceType.ONE_TO_MANY) {
            this._joins[aliasedName] = this.helper.joinOneToReference(prop, fromAlias, alias, type, cond);
        }
        else if (prop.reference === core_1.ReferenceType.MANY_TO_MANY) {
            let pivotAlias = alias;
            if (type !== 'pivotJoin') {
                const oldPivotAlias = this.getAliasForJoinPath(path + '[pivot]');
                pivotAlias = oldPivotAlias !== null && oldPivotAlias !== void 0 ? oldPivotAlias : `e${this.aliasCounter++}`;
            }
            const joins = this.helper.joinManyToManyReference(prop, fromAlias, alias, pivotAlias, type, cond);
            Object.assign(this._joins, joins);
            this._aliasMap[pivotAlias] = prop.pivotTable;
        }
        else if (prop.reference === core_1.ReferenceType.ONE_TO_ONE) {
            this._joins[aliasedName] = this.helper.joinOneToReference(prop, fromAlias, alias, type, cond);
        }
        else { // MANY_TO_ONE
            this._joins[aliasedName] = this.helper.joinManyToOneReference(prop, fromAlias, alias, type, cond);
        }
        this._joins[aliasedName].path = path;
    }
    prepareFields(fields, type = 'where') {
        const ret = [];
        fields.forEach(f => {
            if (!core_1.Utils.isString(f)) {
                return ret.push(f);
            }
            if (this._joins[f] && type === 'where') {
                return ret.push(...this.helper.mapJoinColumns(this.type, this._joins[f]));
            }
            ret.push(this.helper.mapper(f, this.type));
        });
        Object.keys(this._populateMap).forEach(f => {
            if (!fields.includes(f) && type === 'where') {
                ret.push(...this.helper.mapJoinColumns(this.type, this._joins[f]));
            }
            if (this._joins[f].prop.reference !== core_1.ReferenceType.ONE_TO_ONE && this._joins[f].inverseJoinColumns) {
                this._joins[f].inverseJoinColumns.forEach(inverseJoinColumn => {
                    core_1.Utils.renameKey(this._cond, inverseJoinColumn, `${this._joins[f].alias}.${inverseJoinColumn}`);
                });
            }
        });
        return ret;
    }
    init(type, data, cond) {
        this.type = type;
        this._aliasMap[this.alias] = this.entityName;
        if (![enums_1.QueryType.SELECT, enums_1.QueryType.COUNT].includes(type)) {
            delete this._fields;
        }
        if (data) {
            this._data = this.helper.processData(data);
        }
        if (cond) {
            this.where(cond);
        }
        return this;
    }
    getQueryBase() {
        const qb = this.getKnex();
        if (this._schema) {
            qb.withSchema(this._schema);
        }
        switch (this.type) {
            case enums_1.QueryType.SELECT:
                qb.select(this.prepareFields(this._fields));
                if (this.flags.has(core_1.QueryFlag.DISTINCT)) {
                    qb.distinct();
                }
                this.helper.processJoins(qb, this._joins);
                break;
            case enums_1.QueryType.COUNT: {
                const m = this.flags.has(core_1.QueryFlag.DISTINCT) ? 'countDistinct' : 'count';
                qb[m]({ count: this._fields.map(f => this.helper.mapper(f, this.type)) });
                this.helper.processJoins(qb, this._joins);
                break;
            }
            case enums_1.QueryType.INSERT:
                qb.insert(this._data);
                break;
            case enums_1.QueryType.UPDATE:
                qb.update(this._data);
                this.helper.updateVersionProperty(qb);
                break;
            case enums_1.QueryType.DELETE:
                qb.delete();
                break;
            case enums_1.QueryType.TRUNCATE:
                qb.truncate();
                break;
        }
        return qb;
    }
    finalize() {
        var _a, _b;
        if (this.finalized) {
            return;
        }
        if (!this.type) {
            this.select('*');
        }
        const meta = this.metadata.find(this.entityName);
        this._populate.forEach(({ field }) => {
            var _a;
            const [fromAlias, fromField] = this.helper.splitField(field);
            const aliasedField = `${fromAlias}.${fromField}`;
            if (this._joins[aliasedField] && this.helper.isOneToOneInverse(field)) {
                return this._populateMap[aliasedField] = this._joins[aliasedField].alias;
            }
            if ((_a = this.metadata.find(field)) === null || _a === void 0 ? void 0 : _a.pivotTable) { // pivot table entity
                this.autoJoinPivotTable(field);
            }
            else if (meta && this.helper.isOneToOneInverse(field)) {
                const prop = meta.properties[field];
                this._joins[prop.name] = this.helper.joinOneToReference(prop, this.alias, `e${this.aliasCounter++}`, 'leftJoin');
                this._populateMap[field] = this._joins[field].alias;
            }
        });
        if (meta && (((_a = this._fields) === null || _a === void 0 ? void 0 : _a.includes('*')) || ((_b = this._fields) === null || _b === void 0 ? void 0 : _b.includes(`${this.alias}.*`)))) {
            Object.values(meta.properties)
                .filter(prop => prop.formula)
                .forEach(prop => {
                const alias = this.knex.ref(this.alias).toString();
                const aliased = this.knex.ref(prop.fieldNames[0]).toString();
                this.addSelect(`${prop.formula(alias)} as ${aliased}`);
            });
        }
        core_1.QueryHelper.processObjectParams(this._data);
        core_1.QueryHelper.processObjectParams(this._cond);
        core_1.QueryHelper.processObjectParams(this._having);
        this.finalized = true;
        if (meta && this.flags.has(core_1.QueryFlag.PAGINATE) && this._limit > 0) {
            this.wrapPaginateSubQuery(meta);
        }
        if (meta && (this.flags.has(core_1.QueryFlag.UPDATE_SUB_QUERY) || this.flags.has(core_1.QueryFlag.DELETE_SUB_QUERY))) {
            this.wrapModifySubQuery(meta);
        }
    }
    wrapPaginateSubQuery(meta) {
        const pks = this.prepareFields(meta.primaryKeys, 'sub-query');
        const subQuery = this.clone().limit(undefined).offset(undefined);
        subQuery.finalized = true;
        const knexQuery = subQuery.as(this.alias).clearSelect().select(pks);
        // 3 sub-queries are needed to get around mysql limitations with order by + limit + where in + group by (o.O)
        // https://stackoverflow.com/questions/17892762/mysql-this-version-of-mysql-doesnt-yet-support-limit-in-all-any-some-subqu
        const subSubQuery = this.getKnex().select(pks).from(knexQuery).groupBy(pks).limit(this._limit);
        if (this._offset) {
            subSubQuery.offset(this._offset);
        }
        const subSubSubQuery = this.getKnex().select(pks).from(subSubQuery.as(this.alias));
        this._limit = undefined;
        this._offset = undefined;
        this.select(this._fields).where({ [core_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: { $in: subSubSubQuery } });
    }
    wrapModifySubQuery(meta) {
        const subQuery = this.clone();
        subQuery.finalized = true;
        // wrap one more time to get around MySQL limitations
        // https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause
        const subSubQuery = this.getKnex().select(this.prepareFields(meta.primaryKeys)).from(subQuery.as(this.alias));
        const method = this.flags.has(core_1.QueryFlag.UPDATE_SUB_QUERY) ? 'update' : 'delete';
        this[method](this._data).where({
            [core_1.Utils.getPrimaryKeyHash(meta.primaryKeys)]: { $in: subSubQuery },
        });
    }
    autoJoinPivotTable(field) {
        const pivotMeta = this.metadata.find(field);
        const owner = Object.values(pivotMeta.properties).find(prop => prop.reference === core_1.ReferenceType.MANY_TO_ONE && prop.owner);
        const inverse = Object.values(pivotMeta.properties).find(prop => prop.reference === core_1.ReferenceType.MANY_TO_ONE && !prop.owner);
        const prop = this._cond[pivotMeta.name + '.' + owner.name] || this._orderBy[pivotMeta.name + '.' + owner.name] ? inverse : owner;
        const pivotAlias = this.getNextAlias();
        this._joins[field] = this.helper.joinPivotTable(field, prop, this.alias, pivotAlias, 'leftJoin');
        core_1.Utils.renameKey(this._cond, `${field}.${owner.name}`, core_1.Utils.getPrimaryKeyHash(owner.fieldNames.map(fieldName => `${pivotAlias}.${fieldName}`)));
        core_1.Utils.renameKey(this._cond, `${field}.${inverse.name}`, core_1.Utils.getPrimaryKeyHash(inverse.fieldNames.map(fieldName => `${pivotAlias}.${fieldName}`)));
        this._populateMap[field] = this._joins[field].alias;
    }
}
exports.QueryBuilder = QueryBuilder;
