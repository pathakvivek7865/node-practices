"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectHydrator = void 0;
const Hydrator_1 = require("./Hydrator");
const Collection_1 = require("../entity/Collection");
const EntityAssigner_1 = require("../entity/EntityAssigner");
const Reference_1 = require("../entity/Reference");
const Utils_1 = require("../utils/Utils");
const enums_1 = require("../enums");
class ObjectHydrator extends Hydrator_1.Hydrator {
    hydrateProperty(entity, prop, data, newEntity, convertCustomTypes) {
        if (prop.reference === enums_1.ReferenceType.MANY_TO_ONE || prop.reference === enums_1.ReferenceType.ONE_TO_ONE) {
            this.hydrateToOne(data[prop.name], entity, prop);
        }
        else if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY || prop.reference === enums_1.ReferenceType.MANY_TO_MANY) {
            this.hydrateToMany(entity, prop, data[prop.name], newEntity);
        }
        else if (prop.reference === enums_1.ReferenceType.EMBEDDED) {
            this.hydrateEmbeddable(entity, prop, data);
        }
        else { // ReferenceType.SCALAR
            this.hydrateScalar(entity, prop, data[prop.name], convertCustomTypes);
        }
    }
    hydrateScalar(entity, prop, value, convertCustomTypes) {
        if (typeof value === 'undefined' || (prop.getter && !prop.setter)) {
            return;
        }
        if (prop.customType && convertCustomTypes) {
            value = prop.customType.convertToJSValue(value, this.em.getDriver().getPlatform());
        }
        entity[prop.name] = value;
    }
    hydrateEmbeddable(entity, prop, data) {
        const value = {};
        Object.values(entity.__helper.__meta.properties).filter(p => { var _a; return ((_a = p.embedded) === null || _a === void 0 ? void 0 : _a[0]) === prop.name; }).forEach(childProp => {
            value[childProp.embedded[1]] = data[childProp.name];
        });
        entity[prop.name] = Object.create(prop.embeddable.prototype);
        Object.keys(value).forEach(k => entity[prop.name][k] = value[k]);
    }
    hydrateToMany(entity, prop, value, newEntity) {
        if (Array.isArray(value)) {
            const items = value.map((value) => this.createCollectionItem(prop, value, newEntity));
            const coll = Collection_1.Collection.create(entity, prop.name, items, !!newEntity);
            coll.setDirty(!!newEntity);
        }
        else if (!entity[prop.name]) {
            const items = this.em.getDriver().getPlatform().usesPivotTable() || !prop.owner ? undefined : [];
            const coll = Collection_1.Collection.create(entity, prop.name, items, !!(value || newEntity));
            coll.setDirty(false);
        }
    }
    hydrateToOne(value, entity, prop) {
        if (typeof value === 'undefined') {
            return;
        }
        if (Utils_1.Utils.isPrimaryKey(value, true)) {
            entity[prop.name] = Reference_1.Reference.wrapReference(this.factory.createReference(prop.type, value, { merge: true }), prop);
        }
        else if (Utils_1.Utils.isObject(value)) {
            entity[prop.name] = Reference_1.Reference.wrapReference(this.factory.create(prop.type, value, { initialized: true, merge: true }), prop);
        }
        else if (value === null) {
            entity[prop.name] = null;
        }
        if (entity[prop.name]) {
            EntityAssigner_1.EntityAssigner.autoWireOneToOne(prop, entity);
        }
    }
    createCollectionItem(prop, value, newEntity) {
        const meta = this.em.getMetadata().get(prop.type);
        if (Utils_1.Utils.isPrimaryKey(value, meta.compositePK)) {
            const ref = this.factory.createReference(prop.type, value, { merge: true });
            this.em.merge(ref);
            return ref;
        }
        if (Utils_1.Utils.isEntity(value)) {
            return value;
        }
        return this.factory.create(prop.type, value, { newEntity });
    }
}
exports.ObjectHydrator = ObjectHydrator;
