import { EntityManager } from '../EntityManager';
import { EntityData, EntityName, AnyEntity, Primary, Populate, Loaded, New, FilterQuery } from '../typings';
import { QueryOrderMap } from '../enums';
import { FindOneOptions, FindOneOrFailOptions, FindOptions } from '../drivers/IDatabaseDriver';
import { IdentifiedReference } from './Reference';
export declare class EntityRepository<T extends AnyEntity<T>> {
    protected readonly em: EntityManager;
    protected readonly entityName: EntityName<T>;
    constructor(em: EntityManager, entityName: EntityName<T>);
    persist(entity: AnyEntity | AnyEntity[]): EntityManager;
    persistAndFlush(entity: AnyEntity | AnyEntity[]): Promise<void>;
    /**
     * @deprecated use `persist()`
     */
    persistLater(entity: AnyEntity | AnyEntity[]): void;
    findOne<P extends Populate<T> = any>(where: FilterQuery<T>, populate?: P, orderBy?: QueryOrderMap): Promise<Loaded<T, P> | null>;
    findOne<P extends Populate<T> = any>(where: FilterQuery<T>, populate?: FindOneOptions<T, P>, orderBy?: QueryOrderMap): Promise<Loaded<T, P> | null>;
    findOneOrFail<P extends Populate<T> = any>(where: FilterQuery<T>, populate?: P, orderBy?: QueryOrderMap): Promise<Loaded<T, P>>;
    findOneOrFail<P extends Populate<T> = any>(where: FilterQuery<T>, populate?: FindOneOrFailOptions<T, P>, orderBy?: QueryOrderMap): Promise<Loaded<T, P>>;
    find<P extends Populate<T> = any>(where: FilterQuery<T>, options?: FindOptions<T, P>): Promise<Loaded<T, P>[]>;
    find<P extends Populate<T> = any>(where: FilterQuery<T>, populate?: P, orderBy?: QueryOrderMap, limit?: number, offset?: number): Promise<Loaded<T, P>[]>;
    findAndCount<P extends Populate<T> = any>(where: FilterQuery<T>, options?: FindOptions<T>): Promise<[Loaded<T, P>[], number]>;
    findAndCount<P extends Populate<T> = any>(where: FilterQuery<T>, populate?: P, orderBy?: QueryOrderMap, limit?: number, offset?: number): Promise<[Loaded<T, P>[], number]>;
    findAll<P extends Populate<T> = any>(options?: FindOptions<T, P>): Promise<Loaded<T, P>[]>;
    findAll<P extends Populate<T> = any>(populate?: P, orderBy?: QueryOrderMap, limit?: number, offset?: number): Promise<Loaded<T, P>[]>;
    remove(entity: AnyEntity): EntityManager;
    removeAndFlush(entity: AnyEntity): Promise<void>;
    /**
     * @deprecated use `remove()`
     */
    removeLater(entity: AnyEntity): void;
    flush(): Promise<void>;
    nativeInsert(data: EntityData<T>): Promise<Primary<T>>;
    nativeUpdate(where: FilterQuery<T>, data: EntityData<T>): Promise<number>;
    nativeDelete(where: FilterQuery<T> | any): Promise<number>;
    map(result: EntityData<T>): T;
    /**
     * Gets a reference to the entity identified by the given type and identifier without actually loading it, if the entity is not yet loaded
     */
    getReference<PK extends keyof T>(id: Primary<T>, wrapped: true): IdentifiedReference<T, PK>;
    getReference<PK extends keyof T = keyof T>(id: Primary<T>): T;
    getReference<PK extends keyof T = keyof T>(id: Primary<T>, wrapped: false): T;
    canPopulate(property: string): boolean;
    populate<P extends string | keyof T | Populate<T>>(entities: T, populate: P, where?: FilterQuery<T>, orderBy?: QueryOrderMap, refresh?: boolean, validate?: boolean): Promise<Loaded<T, P>>;
    populate<P extends string | keyof T | Populate<T>>(entities: T[], populate: P, where?: FilterQuery<T>, orderBy?: QueryOrderMap, refresh?: boolean, validate?: boolean): Promise<Loaded<T, P>[]>;
    populate<P extends string | keyof T | Populate<T>>(entities: T | T[], populate: P, where?: FilterQuery<T>, orderBy?: QueryOrderMap, refresh?: boolean, validate?: boolean): Promise<Loaded<T, P> | Loaded<T, P>[]>;
    /**
     * Creates new instance of given entity and populates it with given data
     */
    create<P extends Populate<T> = string[]>(data: EntityData<T>): New<T, P>;
    /**
     * Shortcut for `wrap(entity).assign(data, { em })`
     */
    assign(entity: T, data: EntityData<T>): T;
    count(where?: FilterQuery<T>): Promise<number>;
}
