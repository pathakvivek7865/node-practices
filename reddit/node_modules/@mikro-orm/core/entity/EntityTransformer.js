"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityTransformer = void 0;
const ArrayCollection_1 = require("./ArrayCollection");
const wrap_1 = require("./wrap");
const Utils_1 = require("../utils/Utils");
class EntityTransformer {
    static toObject(entity, ignoreFields = [], visited = []) {
        const wrapped = entity.__helper;
        const platform = wrapped.__internal.platform;
        const meta = wrapped.__meta;
        const ret = {};
        meta.primaryKeys
            .filter(pk => !Utils_1.Utils.isDefined(entity[pk], true) || !(meta.properties[pk].hidden || ignoreFields.includes(pk)))
            .map(pk => {
            let value;
            if (meta.properties[pk].serializer) {
                value = meta.properties[pk].serializer(entity[pk]);
            }
            else if (Utils_1.Utils.isEntity(entity[pk], true)) {
                value = EntityTransformer.processEntity(pk, entity, ignoreFields, visited);
            }
            else {
                value = platform.normalizePrimaryKey(Utils_1.Utils.getPrimaryKeyValue(entity, [pk]));
            }
            return [pk, value];
        })
            .forEach(([pk, value]) => ret[this.propertyName(meta, pk, platform)] = value);
        if ((!wrapped.isInitialized() && Utils_1.Utils.isDefined(wrapped.__primaryKey, true)) || visited.includes(entity.__helper.__uuid)) {
            return ret;
        }
        visited.push(entity.__helper.__uuid);
        // normal properties
        Object.keys(entity)
            .filter(prop => this.isVisible(meta, prop, ignoreFields))
            .map(prop => [prop, EntityTransformer.processProperty(prop, entity, ignoreFields, visited)])
            .filter(([, value]) => typeof value !== 'undefined')
            .forEach(([prop, value]) => ret[this.propertyName(meta, prop)] = value);
        // decorated getters
        Object.values(meta.properties)
            .filter(prop => prop.getter && !prop.hidden && typeof entity[prop.name] !== 'undefined')
            .forEach(prop => ret[this.propertyName(meta, prop.name)] = entity[prop.name]);
        // decorated get methods
        Object.values(meta.properties)
            .filter(prop => prop.getterName && !prop.hidden && entity[prop.getterName] instanceof Function)
            .forEach(prop => ret[this.propertyName(meta, prop.name)] = entity[prop.getterName]());
        return ret;
    }
    static isVisible(meta, prop, ignoreFields) {
        const visible = meta.properties[prop] && !meta.properties[prop].hidden;
        return visible && !meta.primaryKeys.includes(prop) && !prop.startsWith('_') && !ignoreFields.includes(prop);
    }
    static propertyName(meta, prop, platform) {
        if (meta.properties[prop].serializedName) {
            return meta.properties[prop].serializedName;
        }
        if (meta.properties[prop].primary && platform) {
            return platform.getSerializedPrimaryKeyField(prop);
        }
        return prop;
    }
    static processProperty(prop, entity, ignoreFields, visited) {
        const wrapped = entity.__helper;
        const property = wrapped.__meta.properties[prop];
        const platform = wrapped.__internal.platform;
        /* istanbul ignore next */
        const serializer = property === null || property === void 0 ? void 0 : property.serializer;
        if (serializer) {
            return serializer(entity[prop]);
        }
        /* istanbul ignore next */
        const customType = property === null || property === void 0 ? void 0 : property.customType;
        if (customType) {
            return customType.toJSON(entity[prop], platform);
        }
        if (entity[prop] instanceof ArrayCollection_1.ArrayCollection) {
            return EntityTransformer.processCollection(prop, entity);
        }
        if (Utils_1.Utils.isEntity(entity[prop], true)) {
            return EntityTransformer.processEntity(prop, entity, ignoreFields, visited);
        }
        return entity[prop];
    }
    static processEntity(prop, entity, ignoreFields, visited) {
        const child = entity[prop];
        const wrapped = child.__helper;
        if (wrapped.isInitialized() && wrapped.__populated && child !== entity && !wrapped.__lazyInitialized) {
            const args = [...wrapped.__meta.toJsonParams.map(() => undefined), ignoreFields, visited];
            return wrap_1.wrap(child).toJSON(...args);
        }
        return wrapped.__internal.platform.normalizePrimaryKey(wrapped.__primaryKey);
    }
    static processCollection(prop, entity) {
        const col = entity[prop];
        if (col.isInitialized(true) && col.shouldPopulate()) {
            return col.toArray();
        }
        if (col.isInitialized()) {
            return col.getIdentifiers();
        }
    }
}
exports.EntityTransformer = EntityTransformer;
