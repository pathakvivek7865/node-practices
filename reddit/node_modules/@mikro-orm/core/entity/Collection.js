"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = void 0;
const ArrayCollection_1 = require("./ArrayCollection");
const Utils_1 = require("../utils/Utils");
const errors_1 = require("../errors");
const enums_1 = require("../enums");
const Reference_1 = require("./Reference");
class Collection extends ArrayCollection_1.ArrayCollection {
    constructor(owner, items, initialized = true) {
        super(owner, items);
        this.snapshot = []; // used to create a diff of the collection at commit time, undefined marks overridden values so we need to wipe when flushing
        this.dirty = false;
        this._populated = false;
        this._lazyInitialized = false;
        this.initialized = !!items || initialized;
        Object.defineProperty(this, 'snapshot', { enumerable: false });
        Object.defineProperty(this, '_populated', { enumerable: false });
        Object.defineProperty(this, '_lazyInitialized', { enumerable: false });
        Object.defineProperty(this, '$', { value: this.items });
        Object.defineProperty(this, 'get', { value: () => this.items });
    }
    /**
     * Creates new Collection instance, assigns it to the owning entity and sets the items to it (propagating them to their inverse sides)
     */
    static create(owner, prop, items, initialized) {
        const coll = new Collection(owner, items, initialized);
        owner[prop] = coll;
        if (items) {
            coll.set(items);
        }
        return coll;
    }
    /**
     * Initializes the collection and returns the items
     */
    async loadItems() {
        if (!this.isInitialized(true)) {
            await this.init();
        }
        return super.getItems();
    }
    /**
     * Returns the items (the collection must be initialized)
     */
    getItems(check = true) {
        if (check) {
            this.checkInitialized();
        }
        return super.getItems();
    }
    toJSON() {
        if (!this.isInitialized()) {
            return [];
        }
        return super.toJSON();
    }
    add(...items) {
        const unwrapped = items.map(i => Reference_1.Reference.unwrapReference(i));
        unwrapped.map(item => this.validateItemType(item));
        this.modify('add', unwrapped);
        this.cancelOrphanRemoval(unwrapped);
    }
    set(items) {
        const unwrapped = items.map(i => Reference_1.Reference.unwrapReference(i));
        unwrapped.map(item => this.validateItemType(item));
        this.validateModification(unwrapped);
        super.set(unwrapped);
        this.setDirty();
        this.cancelOrphanRemoval(unwrapped);
    }
    /**
     * @internal
     */
    hydrate(items, validate = false, takeSnapshot = true) {
        if (validate) {
            this.validateModification(items);
        }
        const wasInitialized = this.initialized;
        const wasDirty = this.dirty;
        this.initialized = true;
        super.hydrate(items);
        this.dirty = wasDirty;
        if (!wasInitialized && !takeSnapshot) {
            this.snapshot = undefined;
        }
        else if (takeSnapshot) {
            this.takeSnapshot();
        }
    }
    remove(...items) {
        const unwrapped = items.map(i => Reference_1.Reference.unwrapReference(i));
        this.modify('remove', unwrapped);
        const em = this.owner.__helper.__em;
        if (this.property.orphanRemoval && em) {
            for (const item of unwrapped) {
                em.getUnitOfWork().scheduleOrphanRemoval(item);
            }
        }
    }
    contains(item, check = true) {
        if (check) {
            this.checkInitialized();
        }
        return super.contains(item);
    }
    count() {
        this.checkInitialized();
        return super.count();
    }
    shouldPopulate() {
        return this._populated && !this._lazyInitialized;
    }
    populated(populated = true) {
        this._populated = populated;
        this._lazyInitialized = false;
    }
    isDirty() {
        return this.dirty;
    }
    setDirty(dirty = true) {
        this.dirty = dirty;
    }
    async init(populate = [], where, orderBy) {
        const options = Utils_1.Utils.isObject(populate) ? populate : { populate, where, orderBy };
        const em = this.owner.__helper.__em;
        if (!em) {
            throw errors_1.ValidationError.entityNotManaged(this.owner);
        }
        if (!this.initialized && this.property.reference === enums_1.ReferenceType.MANY_TO_MANY && em.getDriver().getPlatform().usesPivotTable()) {
            const map = await em.getDriver().loadFromPivotTable(this.property, [this.owner.__helper.__primaryKeys], options.where, options.orderBy);
            this.hydrate(map[this.owner.__helper.__serializedPrimaryKey].map((item) => em.merge(this.property.type, item, false, true)));
            this._lazyInitialized = true;
            return this;
        }
        // do not make db call if we know we will get no results
        if (this.property.reference === enums_1.ReferenceType.MANY_TO_MANY && (this.property.owner || em.getDriver().getPlatform().usesPivotTable()) && this.length === 0) {
            this.initialized = true;
            this.dirty = false;
            this._lazyInitialized = true;
            return this;
        }
        where = this.createCondition(options.where);
        const order = [...this.items]; // copy order of references
        const customOrder = !!options.orderBy;
        orderBy = this.createOrderBy(options.orderBy);
        const items = await em.find(this.property.type, where, options.populate, orderBy);
        if (!customOrder) {
            this.reorderItems(items, order);
        }
        this.items.length = 0;
        this.items.push(...items);
        Object.assign(this, items);
        this.initialized = true;
        this.dirty = false;
        this._lazyInitialized = true;
        return this;
    }
    /**
     * @internal
     */
    takeSnapshot() {
        this.snapshot = [...this.items];
        this.setDirty(false);
    }
    /**
     * @internal
     */
    getSnapshot() {
        return this.snapshot;
    }
    createCondition(cond = {}) {
        if (this.property.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            cond[this.property.mappedBy] = this.owner.__helper.__primaryKey;
        }
        else { // MANY_TO_MANY
            this.createManyToManyCondition(cond);
        }
        return cond;
    }
    createOrderBy(orderBy = {}) {
        if (Utils_1.Utils.isEmpty(orderBy) && this.property.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            const defaultOrder = this.property.referencedColumnNames.reduce((o, name) => {
                o[name] = enums_1.QueryOrder.ASC;
                return o;
            }, {});
            orderBy = this.property.orderBy || defaultOrder;
        }
        return orderBy;
    }
    createManyToManyCondition(cond) {
        if (this.property.owner || this.owner.__helper.__internal.platform.usesPivotTable()) {
            const pk = this.items[0].__helper.__meta.primaryKeys[0]; // we know there is at least one item as it was checked in load method
            cond[pk] = { $in: this.items.map((item) => item.__helper.__primaryKey) };
        }
        else {
            cond[this.property.mappedBy] = this.owner.__helper.__primaryKey;
        }
    }
    modify(method, items) {
        if (method === 'remove') {
            this.checkInitialized();
        }
        this.validateModification(items);
        super[method](...items);
        this.setDirty();
    }
    checkInitialized() {
        if (!this.isInitialized()) {
            throw new Error(`Collection<${this.property.type}> of entity ${this.owner.constructor.name}[${this.owner.__helper.__primaryKey}] not initialized`);
        }
    }
    /**
     * re-orders items after searching with `$in` operator
     */
    reorderItems(items, order) {
        if (this.property.reference === enums_1.ReferenceType.MANY_TO_MANY && this.property.owner) {
            items.sort((a, b) => order.indexOf(a) - order.indexOf(b));
        }
    }
    cancelOrphanRemoval(items) {
        const em = this.owner.__helper.__em;
        if (!em) {
            return;
        }
        for (const item of items) {
            em.getUnitOfWork().cancelOrphanRemoval(item);
        }
    }
    validateItemType(item) {
        if (!Utils_1.Utils.isEntity(item)) {
            throw errors_1.ValidationError.notEntity(this.owner, this.property, item);
        }
    }
    validateModification(items) {
        // currently we allow persisting to inverse sides only in SQL drivers
        if (this.owner.__helper.__internal.platform.usesPivotTable() || !this.property.mappedBy) {
            return;
        }
        const check = (item) => {
            if (item.__helper.isInitialized()) {
                return false;
            }
            return !item[this.property.mappedBy] && this.property.reference === enums_1.ReferenceType.MANY_TO_MANY;
        };
        // throw if we are modifying inverse side of M:N collection when owning side is initialized (would be ignored when persisting)
        if (items.find(item => check(item))) {
            throw errors_1.ValidationError.cannotModifyInverseCollection(this.owner, this.property);
        }
    }
}
exports.Collection = Collection;
