"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeSetPersister = void 0;
const entity_1 = require("../entity");
const ChangeSet_1 = require("./ChangeSet");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
class ChangeSetPersister {
    constructor(driver, identifierMap, metadata, hydrator, config) {
        this.driver = driver;
        this.identifierMap = identifierMap;
        this.metadata = metadata;
        this.hydrator = hydrator;
        this.config = config;
    }
    async executeInserts(changeSets, ctx) {
        changeSets.forEach(changeSet => this.processProperties(changeSet));
        for (const changeSet of changeSets) {
            await this.persistNewEntity(changeSet, ctx);
        }
    }
    async executeUpdates(changeSets, ctx) {
        changeSets.forEach(changeSet => this.processProperties(changeSet));
        for (const changeSet of changeSets) {
            await this.persistManagedEntity(changeSet, ctx);
        }
    }
    async executeDeletes(changeSets, ctx) {
        const meta = changeSets[0].entity.__helper.__meta;
        const pk = utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
        if (meta.compositePK) {
            const pks = changeSets.map(cs => cs.entity.__helper.__primaryKeys);
            await this.driver.nativeDelete(changeSets[0].name, { [pk]: { $in: pks } }, ctx);
        }
        else {
            const pks = changeSets.map(cs => cs.entity.__helper.__primaryKey);
            await this.driver.nativeDelete(changeSets[0].name, { [pk]: { $in: pks } }, ctx);
        }
    }
    processProperties(changeSet) {
        const meta = this.metadata.find(changeSet.name);
        for (const prop of Object.values(meta.properties)) {
            this.processProperty(changeSet, prop);
        }
    }
    async persistNewEntity(changeSet, ctx) {
        const meta = this.metadata.find(changeSet.name);
        const wrapped = changeSet.entity.__helper;
        const res = await this.driver.nativeInsert(changeSet.name, changeSet.payload, ctx);
        const hasPrimaryKey = utils_1.Utils.isDefined(wrapped.__primaryKey, true);
        this.mapReturnedValues(changeSet.entity, res, meta);
        if (!hasPrimaryKey) {
            this.mapPrimaryKey(meta, res.insertId, changeSet);
        }
        this.markAsPopulated(changeSet, meta);
        wrapped.__initialized = true;
        wrapped.__managed = true;
        await this.processOptimisticLock(meta, changeSet, res, ctx);
        changeSet.persisted = true;
    }
    async persistManagedEntity(changeSet, ctx) {
        const meta = this.metadata.find(changeSet.name);
        const res = await this.updateEntity(meta, changeSet, ctx);
        this.mapReturnedValues(changeSet.entity, res, meta);
        await this.processOptimisticLock(meta, changeSet, res, ctx);
        changeSet.persisted = true;
    }
    mapPrimaryKey(meta, value, changeSet) {
        const prop = meta.properties[meta.primaryKeys[0]];
        const insertId = prop.customType ? prop.customType.convertToJSValue(value, this.driver.getPlatform()) : value;
        const wrapped = changeSet.entity.__helper;
        wrapped.__primaryKey = utils_1.Utils.isDefined(wrapped.__primaryKey, true) ? wrapped.__primaryKey : insertId;
        this.identifierMap.get(wrapped.__uuid).setValue(changeSet.entity[prop.name]);
    }
    /**
     * Sets populate flag to new entities so they are serialized like if they were loaded from the db
     */
    markAsPopulated(changeSet, meta) {
        if (!this.config.get('populateAfterFlush')) {
            return;
        }
        changeSet.entity.__helper.populated();
        Object.values(meta.properties).forEach(prop => {
            const value = changeSet.entity[prop.name];
            if (utils_1.Utils.isEntity(value, true)) {
                value.__helper.populated();
            }
            else if (utils_1.Utils.isCollection(value)) {
                value.populated();
            }
        });
    }
    async updateEntity(meta, changeSet, ctx) {
        if (!meta.versionProperty || !changeSet.entity[meta.versionProperty]) {
            return this.driver.nativeUpdate(changeSet.name, changeSet.entity.__helper.__primaryKey, changeSet.payload, ctx);
        }
        const cond = Object.assign(Object.assign({}, utils_1.Utils.getPrimaryKeyCond(changeSet.entity, meta.primaryKeys)), { [meta.versionProperty]: changeSet.entity[meta.versionProperty] });
        return this.driver.nativeUpdate(changeSet.name, cond, changeSet.payload, ctx);
    }
    async processOptimisticLock(meta, changeSet, res, ctx) {
        if (!meta.versionProperty) {
            return;
        }
        if (changeSet.type === ChangeSet_1.ChangeSetType.UPDATE && res && !res.affectedRows) {
            throw errors_1.OptimisticLockError.lockFailed(changeSet.entity);
        }
        const e = await this.driver.findOne(meta.name, changeSet.entity.__helper.__primaryKey, {
            fields: [meta.versionProperty],
        }, ctx);
        changeSet.entity[meta.versionProperty] = e[meta.versionProperty];
    }
    processProperty(changeSet, prop) {
        const value = changeSet.payload[prop.name];
        if (value instanceof entity_1.EntityIdentifier) {
            changeSet.payload[prop.name] = value.getValue();
        }
        if (prop.onCreate && changeSet.type === ChangeSet_1.ChangeSetType.CREATE) {
            changeSet.entity[prop.name] = changeSet.payload[prop.name] = prop.onCreate(changeSet.entity);
            if (prop.primary) {
                this.mapPrimaryKey(changeSet.entity.__helper.__meta, changeSet.entity[prop.name], changeSet);
            }
        }
        if (prop.onUpdate && changeSet.type === ChangeSet_1.ChangeSetType.UPDATE) {
            changeSet.entity[prop.name] = changeSet.payload[prop.name] = prop.onUpdate(changeSet.entity);
        }
    }
    /**
     * Maps values returned via `returning` statement (postgres) or the inserted id (other sql drivers).
     * No need to handle composite keys here as they need to be set upfront.
     */
    mapReturnedValues(entity, res, meta) {
        if (res.row && Object.keys(res.row).length > 0) {
            const data = Object.values(meta.properties).reduce((data, prop) => {
                if (prop.fieldNames && res.row[prop.fieldNames[0]] && !utils_1.Utils.isDefined(entity[prop.name], true)) {
                    data[prop.name] = res.row[prop.fieldNames[0]];
                }
                return data;
            }, {});
            this.hydrator.hydrate(entity, meta, data, false, true);
        }
    }
}
exports.ChangeSetPersister = ChangeSetPersister;
