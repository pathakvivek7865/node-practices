import { MetadataStorage } from '../metadata';
import { AnyEntity } from '../typings';
import { EntityIdentifier } from '../entity';
import { ChangeSet } from './ChangeSet';
import { Transaction } from '../connections';
import { Configuration } from '../utils';
import { IDatabaseDriver } from '../drivers';
import { Hydrator } from '../hydration';
export declare class ChangeSetPersister {
    private readonly driver;
    private readonly identifierMap;
    private readonly metadata;
    private readonly hydrator;
    private readonly config;
    constructor(driver: IDatabaseDriver, identifierMap: Map<string, EntityIdentifier>, metadata: MetadataStorage, hydrator: Hydrator, config: Configuration);
    executeInserts<T extends AnyEntity<T>>(changeSets: ChangeSet<T>[], ctx?: Transaction): Promise<void>;
    executeUpdates<T extends AnyEntity<T>>(changeSets: ChangeSet<T>[], ctx?: Transaction): Promise<void>;
    executeDeletes<T extends AnyEntity<T>>(changeSets: ChangeSet<T>[], ctx?: Transaction): Promise<void>;
    private processProperties;
    private persistNewEntity;
    private persistManagedEntity;
    private mapPrimaryKey;
    /**
     * Sets populate flag to new entities so they are serialized like if they were loaded from the db
     */
    private markAsPopulated;
    private updateEntity;
    private processOptimisticLock;
    private processProperty;
    /**
     * Maps values returned via `returning` statement (postgres) or the inserted id (other sql drivers).
     * No need to handle composite keys here as they need to be set upfront.
     */
    private mapReturnedValues;
}
