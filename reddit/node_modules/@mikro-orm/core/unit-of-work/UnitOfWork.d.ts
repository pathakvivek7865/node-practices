import { AnyEntity, EntityData, FilterQuery, Primary } from '../typings';
import { Collection, Reference } from '../entity';
import { ChangeSet } from './ChangeSet';
import { EntityManager } from '../EntityManager';
import { LockMode } from '../enums';
export declare class UnitOfWork {
    private readonly em;
    /** map of references to managed entities */
    private readonly identityMap;
    /** holds copy of identity map so we can compute changes when persisting managed entities */
    private readonly originalEntityData;
    /** map of wrapped primary keys so we can compute change set without eager commit */
    private readonly identifierMap;
    private readonly persistStack;
    private readonly removeStack;
    private readonly orphanRemoveStack;
    private readonly changeSets;
    private readonly collectionUpdates;
    private readonly extraUpdates;
    private readonly metadata;
    private readonly platform;
    private readonly changeSetComputer;
    private readonly changeSetPersister;
    private working;
    constructor(em: EntityManager);
    merge<T extends AnyEntity<T>>(entity: T, visited?: Set<AnyEntity<any>>, mergeData?: boolean): void;
    /**
     * Returns entity from the identity map. For composite keys, you need to pass an array of PKs in the same order as they are defined in `meta.primaryKeys`.
     */
    getById<T extends AnyEntity<T>>(entityName: string, id: Primary<T> | Primary<T>[]): T;
    tryGetById<T extends AnyEntity<T>>(entityName: string, where: FilterQuery<T>, strict?: boolean): T | null;
    getIdentityMap(): Map<string, AnyEntity>;
    getOriginalEntityData(): Map<string, EntityData<AnyEntity>>;
    getPersistStack(): Set<AnyEntity>;
    getRemoveStack(): Set<AnyEntity>;
    getChangeSets(): ChangeSet<AnyEntity>[];
    getCollectionUpdates(): Collection<AnyEntity>[];
    getExtraUpdates(): Set<[AnyEntity, string, (AnyEntity | Reference<AnyEntity>)]>;
    computeChangeSet<T extends AnyEntity<T>>(entity: T): void;
    recomputeSingleChangeSet<T extends AnyEntity<T>>(entity: T): void;
    persist<T extends AnyEntity<T>>(entity: T, visited?: Set<AnyEntity<any>>, checkRemoveStack?: boolean): void;
    remove(entity: AnyEntity, visited?: Set<AnyEntity<any>>): void;
    commit(): Promise<void>;
    lock<T extends AnyEntity<T>>(entity: T, mode: LockMode, version?: number | Date): Promise<void>;
    clear(): void;
    unsetIdentity(entity: AnyEntity): void;
    computeChangeSets(): void;
    scheduleOrphanRemoval(entity: AnyEntity): void;
    cancelOrphanRemoval(entity: AnyEntity): void;
    private findNewEntities;
    private initIdentifier;
    private processReference;
    private processToOneReference;
    private processToManyReference;
    private runHooks;
    private postCommitCleanup;
    private cascade;
    private cascadeReference;
    private isCollectionSelfReferenced;
    private shouldCascade;
    private lockPessimistic;
    private lockOptimistic;
    private fixMissingReference;
    private unwrapReference;
    private persistToDatabase;
    private commitCreateChangeSets;
    private commitUpdateChangeSets;
    private commitDeleteChangeSets;
    /**
     * Orders change sets so FK constrains are maintained, ensures stable order (needed for node < 11)
     */
    private getChangeSetGroups;
    private getCommitOrder;
    private addCommitDependency;
}
