"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChangeSetComputer = void 0;
const utils_1 = require("../utils");
const ChangeSet_1 = require("./ChangeSet");
const enums_1 = require("../enums");
const EntityComparator_1 = require("../utils/EntityComparator");
class ChangeSetComputer {
    constructor(validator, originalEntityData, identifierMap, collectionUpdates, removeStack, metadata, platform) {
        this.validator = validator;
        this.originalEntityData = originalEntityData;
        this.identifierMap = identifierMap;
        this.collectionUpdates = collectionUpdates;
        this.removeStack = removeStack;
        this.metadata = metadata;
        this.platform = platform;
        this.comparator = new EntityComparator_1.EntityComparator(this.metadata, this.platform);
    }
    computeChangeSet(entity) {
        const changeSet = { entity };
        const meta = this.metadata.find(entity.constructor.name);
        if (meta.readonly) {
            return null;
        }
        changeSet.name = meta.name;
        changeSet.type = this.originalEntityData.has(entity.__helper.__uuid) ? ChangeSet_1.ChangeSetType.UPDATE : ChangeSet_1.ChangeSetType.CREATE;
        changeSet.collection = meta.collection;
        changeSet.payload = this.computePayload(entity);
        if (changeSet.type === ChangeSet_1.ChangeSetType.UPDATE) {
            changeSet.originalEntity = this.originalEntityData.get(entity.__helper.__uuid);
        }
        this.validator.validate(changeSet.entity, changeSet.payload, meta);
        for (const prop of Object.values(meta.properties)) {
            this.processReference(changeSet, prop);
        }
        if (changeSet.type === ChangeSet_1.ChangeSetType.UPDATE && Object.keys(changeSet.payload).length === 0) {
            return null;
        }
        return changeSet;
    }
    computePayload(entity) {
        if (this.originalEntityData.get(entity.__helper.__uuid)) {
            return this.comparator.diffEntities(this.originalEntityData.get(entity.__helper.__uuid), entity);
        }
        return this.comparator.prepareEntity(entity);
    }
    processReference(changeSet, prop) {
        const target = changeSet.entity[prop.name];
        // remove items from collection based on removeStack
        if (utils_1.Utils.isCollection(target) && target.isInitialized()) {
            target.getItems()
                .filter(item => this.removeStack.has(item))
                .forEach(item => target.remove(item));
        }
        if (utils_1.Utils.isCollection(target)) { // m:n or 1:m
            this.processToMany(prop, changeSet);
        }
        else if (prop.reference !== enums_1.ReferenceType.SCALAR && target) { // m:1 or 1:1
            this.processToOne(prop, changeSet);
        }
        if (prop.reference === enums_1.ReferenceType.ONE_TO_ONE) {
            this.processOneToOne(prop, changeSet);
        }
    }
    processToOne(prop, changeSet) {
        const pks = this.metadata.find(prop.type).primaryKeys;
        const entity = changeSet.entity[prop.name];
        const isToOneOwner = prop.reference === enums_1.ReferenceType.MANY_TO_ONE || (prop.reference === enums_1.ReferenceType.ONE_TO_ONE && prop.owner);
        if (isToOneOwner && pks.length === 1 && !utils_1.Utils.isDefined(entity[pks[0]], true)) {
            changeSet.payload[prop.name] = this.identifierMap.get(entity.__helper.__uuid);
        }
    }
    processToMany(prop, changeSet) {
        const target = changeSet.entity[prop.name];
        if (!target.isDirty()) {
            return;
        }
        if (prop.owner || target.getItems(false).filter(item => !item.__helper.isInitialized()).length > 0) {
            this.collectionUpdates.push(target);
        }
        else {
            target.setDirty(false); // inverse side with only populated items, nothing to persist
        }
    }
    processOneToOne(prop, changeSet) {
        // check diff, if we had a value on 1:1 before and now it changed (nulled or replaced), we need to trigger orphan removal
        const data = this.originalEntityData.get(changeSet.entity.__helper.__uuid);
        const em = changeSet.entity.__helper.__em;
        if (prop.orphanRemoval && data && data[prop.name] && prop.name in changeSet.payload && em) {
            const orphan = em.getReference(prop.type, data[prop.name]);
            em.getUnitOfWork().scheduleOrphanRemoval(orphan);
        }
    }
}
exports.ChangeSetComputer = ChangeSetComputer;
