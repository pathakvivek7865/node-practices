"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Migrator = void 0;
const umzug_1 = __importStar(require("umzug"));
const core_1 = require("@mikro-orm/core");
const knex_1 = require("@mikro-orm/knex");
const MigrationRunner_1 = require("./MigrationRunner");
const MigrationGenerator_1 = require("./MigrationGenerator");
const MigrationStorage_1 = require("./MigrationStorage");
class Migrator {
    constructor(em) {
        var _a;
        this.em = em;
        this.driver = this.em.getDriver();
        this.schemaGenerator = new knex_1.SchemaGenerator(this.em);
        this.config = this.em.config;
        this.options = this.config.get('migrations');
        this.runner = new MigrationRunner_1.MigrationRunner(this.driver, this.options, this.config);
        this.generator = new MigrationGenerator_1.MigrationGenerator(this.driver, this.config.getNamingStrategy(), this.options);
        this.storage = new MigrationStorage_1.MigrationStorage(this.driver, this.options);
        let migrations = {
            path: core_1.Utils.absolutePath(this.options.path, this.config.get('baseDir')),
            pattern: this.options.pattern,
            customResolver: (file) => this.resolve(file),
        };
        if ((_a = this.options.migrationsList) === null || _a === void 0 ? void 0 : _a.length) {
            const list = this.options.migrationsList.map(migration => this.initialize(migration.class, migration.name));
            migrations = umzug_1.migrationsList(list);
        }
        this.umzug = new umzug_1.default({
            storage: this.storage,
            logging: this.config.get('logger'),
            migrations,
        });
    }
    async createMigration(path, blank = false, initial = false) {
        if (initial) {
            await this.validateInitialMigration();
        }
        const diff = await this.getSchemaDiff(blank, initial);
        if (diff.length === 0) {
            return { fileName: '', code: '', diff };
        }
        const migration = await this.generator.generate(diff, path);
        if (initial) {
            await this.storage.logMigration(migration[1]);
        }
        return {
            fileName: migration[1],
            code: migration[0],
            diff,
        };
    }
    async validateInitialMigration() {
        const executed = await this.getExecutedMigrations();
        const pending = await this.getPendingMigrations();
        if (executed.length > 0 || pending.length > 0) {
            throw new Error('Initial migration cannot be created, as some migrations already exist');
        }
    }
    async getExecutedMigrations() {
        await this.storage.ensureTable();
        return this.storage.getExecutedMigrations();
    }
    async getPendingMigrations() {
        await this.storage.ensureTable();
        return this.umzug.pending();
    }
    async up(options) {
        return this.runMigrations('up', options);
    }
    async down(options) {
        return this.runMigrations('down', options);
    }
    getStorage() {
        return this.storage;
    }
    resolve(file) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const migration = require(file);
        const MigrationClass = Object.values(migration)[0];
        return this.initialize(MigrationClass);
    }
    initialize(MigrationClass, name) {
        const instance = new MigrationClass(this.driver, this.config);
        return {
            name,
            up: () => this.runner.run(instance, 'up'),
            down: () => this.runner.run(instance, 'down'),
        };
    }
    async getSchemaDiff(blank, initial) {
        const lines = [];
        if (blank) {
            lines.push('select 1');
        }
        else if (initial) {
            const dump = await this.schemaGenerator.getCreateSchemaSQL(false);
            lines.push(...dump.split('\n'));
        }
        else {
            const dump = await this.schemaGenerator.getUpdateSchemaSQL(false, this.options.safe, this.options.dropTables);
            lines.push(...dump.split('\n'));
        }
        for (let i = lines.length - 1; i > 0; i--) {
            if (lines[i]) {
                break;
            }
            delete lines[i];
        }
        return lines;
    }
    prefix(options) {
        if (core_1.Utils.isString(options) || Array.isArray(options)) {
            return core_1.Utils.asArray(options).map(m => m.startsWith('Migration') ? m : 'Migration' + m);
        }
        if (!core_1.Utils.isObject(options)) {
            return options;
        }
        if (options.migrations) {
            options.migrations = options.migrations.map(m => this.prefix(m));
        }
        ['from', 'to'].filter(k => options[k]).forEach(k => options[k] = this.prefix(options[k]));
        return options;
    }
    async runMigrations(method, options) {
        await this.storage.ensureTable();
        if (!this.options.transactional || !this.options.allOrNothing) {
            return this.umzug[method](this.prefix(options));
        }
        return this.driver.getConnection().transactional(async (trx) => {
            this.runner.setMasterMigration(trx);
            this.storage.setMasterMigration(trx);
            const ret = await this.umzug[method](this.prefix(options));
            this.runner.unsetMasterMigration();
            this.storage.unsetMasterMigration();
            return ret;
        });
    }
}
exports.Migrator = Migrator;
